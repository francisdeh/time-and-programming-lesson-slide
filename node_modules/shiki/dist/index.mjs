import fs from 'node:fs';
import fsp from 'node:fs/promises';
import { bundledLanguages, bundledThemes, getHighlighter as getHighlighter$1, normalizeTheme, tokenizeAnsiWithTheme } from 'shikiji';
export { toShikiTheme } from 'shikiji';
import { transformerCompactLineOptions } from 'shikiji-transformers';

const _warned = /* @__PURE__ */ new Set();
function warnOnce(message) {
  if (!_warned.has(message)) {
    console.warn(`[shikiji-compat]: ${message}`);
    _warned.add(message);
  }
}
function stubFunction(name) {
  return () => {
    warnOnce(`\`${name}\` is a stub function in \`shikiji-compat\` and does nothing.`);
  };
}
const setCDN = stubFunction("setCDN");
const setOnigasmWASM = stubFunction("setOnigasmWASM");
const setWasm = stubFunction("setWasm");
const setColorReplacements = stubFunction("setColorReplacements");

const BUNDLED_LANGUAGES = bundledLanguages;
const BUNDLED_THEMES = bundledThemes;
async function getHighlighter(options = {}) {
  const themes = options.themes || [];
  const langs = options.langs || [];
  if (options.theme)
    themes.unshift(options.theme);
  if (!themes.length)
    themes.push("nord");
  if (!langs.length)
    langs.push(...Object.keys(bundledLanguages));
  const shikiji = await getHighlighter$1({
    ...options,
    themes,
    langs
  });
  const defaultTheme = shikiji.getLoadedThemes()[0];
  function codeToThemedTokens(code, lang, theme, options2) {
    const tokens = shikiji.codeToThemedTokens(code, {
      includeExplanation: true,
      lang,
      theme: theme || defaultTheme,
      ...options2
    });
    tokens.forEach((line) => {
      line.forEach((token) => {
        token.explanation || (token.explanation = []);
      });
    });
    return tokens;
  }
  function codeToHtml(code, arg1, arg2, options2) {
    const options3 = (typeof arg1 === "string" ? options2 : arg1) || {};
    if (typeof arg1 === "string")
      options3.lang || (options3.lang = arg1);
    if (!("themes" in options3)) {
      options3.theme = "theme" in options3 ? options3.theme || defaultTheme : arg2 || defaultTheme;
    }
    if (options3.lineOptions) {
      options3.transformers || (options3.transformers = []);
      options3.transformers.push(transformerCompactLineOptions(options3.lineOptions));
    }
    return shikiji.codeToHtml(code, options3);
  }
  function ansiToThemedTokens(ansi, options2 = {}) {
    const theme = shikiji.getTheme(options2.theme || shikiji.getLoadedThemes()[0]);
    return tokenizeAnsiWithTheme(theme, ansi);
  }
  return {
    ...shikiji,
    ansiToThemedTokens,
    codeToThemedTokens,
    codeToHtml,
    ansiToHtml(code, options2) {
      return shikiji.codeToHtml(code, {
        lang: "ansi",
        ...options2,
        theme: options2?.theme || defaultTheme
      });
    },
    getBackgroundColor(theme) {
      return shikiji.getTheme(theme).bg;
    },
    getForegroundColor(theme) {
      return shikiji.getTheme(theme).fg;
    },
    /**
     * @deprecated Not supported by Shikiji
     */
    setColorReplacements(..._args) {
      throw new Error("[shikiji-compat] `setColorReplacements` is not supported by Shikiji");
    }
  };
}
async function loadTheme(theme) {
  if (typeof theme === "string") {
    if (bundledThemes[theme] != null)
      return normalizeTheme(await bundledThemes[theme]().then((r) => r.default));
    if (fs.existsSync(theme) && theme.endsWith(".json"))
      return normalizeTheme(JSON.parse(await fsp.readFile(theme, "utf-8")));
    throw new Error(`[shikiji-compat] Unknown theme: ${theme}`);
  } else {
    return normalizeTheme(await normalizeGetter(theme));
  }
}
async function normalizeGetter(p) {
  return Promise.resolve(typeof p === "function" ? p() : p).then((r) => r.default || r);
}

export { BUNDLED_LANGUAGES, BUNDLED_THEMES, getHighlighter as default, getHighlighter, loadTheme, setCDN, setColorReplacements, setOnigasmWASM, setWasm };
